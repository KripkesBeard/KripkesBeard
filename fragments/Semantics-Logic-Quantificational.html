<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Semantics.Logic.Quantificational</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">fragments-0.1.0.0: Formal Semantics via Functional Programming</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Semantics.Logic.Quantificational</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Syntax</a><ul><li><a href="#g:2">Abstract Syntax</a></li></ul></li><li><a href="#g:3">Semantics </a><ul><li><a href="#g:4">Model Structure</a><ul><li><a href="#g:5">Domain</a></li><li><a href="#g:6">Relations</a></li><li><a href="#g:7">Interpretation</a></li></ul></li><li><a href="#g:8">Evaluation</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Quantificational Logic</h1><p>Quantificational logic, also called first-order logic or predicate logic, is the logic which studies subject-predicate pairs and quantification.
This logic allows us to form statements about a domain of objects, their relations to each other, and their relations to the domain as a whole.
It is more expressive than propositional logic because it allows for quantifying over objects in a domain instead of just combining whole sentences via the logical connectives.</p><h2>The Syntax of Quantificational Logic</h2><p>The syntax of quantificational logic requires two separate definitions, terms and formulae.</p><p>A term is either a variable or a constant:</p><p><span class="mathjax">\[
\textrm{Term} ::= \: v \: | \: c
\]</span></p><p>where the variables <span class="mathjax">\(v\)</span> are a different kind of variable than a propositional variable. Here, the variables <span class="mathjax">\(v\)</span> range over objects in the domain.</p><p>For implementation purposes, however, the Haskell grammar for terms only includes constants. The reason for making this decision will be explained 
in the section on semantics, but the idea is that we want to use Haskell's built in handling of variables to manage the complexities which quantification brings.</p><p>A quantificational formula is defined according to the grammar:</p><p><span class="mathjax">\[
\Phi ::= \: P^n(t_1,t_2,...,t_n) \: | \: t_1 = t_2 \: | \: \lnot \: \Phi \: | \: \Phi \land \Phi \: | \: \Phi \lor \Phi \: 
| \: \Phi \rightarrow \Phi \: | \: \forall x \Phi \: | \: \exists x \Phi 
\]</span></p><p>where <span class="mathjax">\(P^n\)</span> is an n-place predicate, <span class="mathjax">\(t_n\)</span> are terms and <span class="mathjax">\(x\)</span> is a variable. A formula conforming to the first clause is atomic and is the quantificational equivalent of a 
propositional atomic sentence if the terms are constants. The quantifying symbols <span class="mathjax">\(\forall\)</span> and <span class="mathjax">\(\exists\)</span> are repsectively known as the universal quantifier 
and the existnetial quantifier, with the first meaning &quot;for all&quot; and the second &quot;there exists&quot;.</p><p>According to the grammar, there are two kinds of new things happening compared to propositional logic. First, instead of an indivisible propositional formula letter, we break the
proposition down into a predicate and the objects it predicates. We can also express equality between two objects in the domain. Syntactically, equality is really just a two place 
predicate, but it has some special semantic properties so we include it in the grammar. Second, we have the introduction of the quantifying symbols <span class="mathjax">\(\forall\)</span> and <span class="mathjax">\(\exists\)</span>. Both 
of them take a variable and a formula to produce a new formula. </p><p>The variable which appears next to the quantifying symbol is said to be &quot;bound&quot; by the quantifier, along with all occurances of the variable in the formula
following the quantifier. The intuitive idea is that we want to treat a quantified variable as if the name itself doesn't matter. <span class="mathjax">\(\forall x\)</span> 
and <span class="mathjax">\(\forall y\)</span> really have the same meaning, we're quantifying over some variable, not a particular object. The only reason we have a 
different variable name is so that we can easily tell which variable is bound by which quantifier in a case like <span class="mathjax">\(\forall x \exists y\)</span>. A formula is said to be 
open if it contains any variable which is not bound by some quantifier. A formula is said to be closed if all of its variables are bound, or if it only 
contains constants. We also sometimes use the word &quot;sentence&quot; to mean a closed formula.</p><p>Dealing with unbound variables is the most annoying part of any logic, and so the reason that the implementation does not consider variables as part of 
the AST grammar is to unload that problem onto Haskell itself. All of this will make sense once the interpretation of a formula is described,
but the idea behind the implementation is to make open formulae impossible to represent.</p><p>The last syntactic idea which needs to be covered is substitution. In a formula which contains variables, we can substitute a term for each occurance of a 
variable by simply replacing each occurance of that variable with the term.  </p><p>Substituting the constant <span class="mathjax">\(c_1\)</span> for the variable <span class="mathjax">\(x_1\)</span> in the formula <span class="mathjax">\(\lnot P_1(x_1,c_2) \land P_2(x_1)\)</span> results in the 
formula <span class="mathjax">\(\lnot P_1(c_1,c_2) \land P_2(c_1)\)</span>.</p><h2>The Semantics of Quantificational Logic</h2><p>The semantics of quantificational logic goes beyond propositional logic in that instead of just mapping sentence to true and false, we want to 
be able to describe objects in a domain of discourse and relations among them. So, an interpretation <span class="mathjax">\(I\)</span> is a pair <span class="mathjax">\(\langle D, R \rangle\)</span>
where <span class="mathjax">\(D\)</span> is the domain of the interpretation and <span class="mathjax">\(R\)</span> is a set of relations on <span class="mathjax">\(D\)</span>. That is, <span class="mathjax">\(D\)</span> is a set of objects which the formulae 
of the language talk about, and <span class="mathjax">\(R\)</span> is a collection of n-tuples on <span class="mathjax">\(D\)</span>. An interpretation assigns one of these n-tuples to each predicate 
in order to tell exactly which objects in the domain the predicate is true of. It also assigns an object in the domain to each constant, which can also be understood as 
assigning a one place predicate true of exactly one object in the domain. </p><p>The recursive truth definition for a quantificational sentence (closed formula) in some interpretation <span class="mathjax">\(I\)</span> is:</p><p><span class="mathjax">\[
\textrm{An atomic sentence} \: \ulcorner P^n(t_1,t_2,...,t_n) \urcorner \: 
\textrm{is true iff the n-tuple containing the objects in \(D\) which \(I\) assigns to \(\ulcorner t_1 \urcorner , \ulcorner t_2 \urcorner,..., \ulcorner t_n \urcorner\) 
is in the relation which \(I\) assigns to \(\ulcorner P^n \urcorner\)}
\]</span></p><p><span class="mathjax">\[
\ulcorner t_1 = t_2 \urcorner \: \textrm{is true iff} \: I \: \textrm{assigns \(\ulcorner t_1 \urcorner\) and \(\ulcorner t_2 \urcorner\) the same object in \(D\)} 
\]</span> </p><p><span class="mathjax">\[
\ulcorner\lnot \: \phi\urcorner \: \textrm{is true iff} \: \ulcorner\phi\urcorner \: \textrm{is false}
\]</span></p><p><span class="mathjax">\[
\ulcorner\phi \: \land \: \psi\urcorner \: \textrm{is true iff} \: \ulcorner\phi\urcorner \: \textrm{is true and} \: \ulcorner\psi\urcorner \: \textrm{is true}
\]</span></p><p><span class="mathjax">\[
\ulcorner\phi \: \lor \: \psi\urcorner \: \textrm{is true iff} \: \ulcorner\phi\urcorner \: \textrm{is true or} \: \ulcorner\psi\urcorner \: \textrm{is true}
\]</span></p><p><span class="mathjax">\[
\ulcorner\phi \: \rightarrow \: \psi\urcorner \: \textrm{is true iff either} \: \ulcorner\lnot \: \phi\urcorner  \: 
\textrm{is true or} \: \ulcorner\psi\urcorner \: \textrm{is true}
\]</span></p><p><span class="mathjax">\[
\ulcorner \forall x \phi \urcorner \: \textrm{is true iff the formula \(\ulcorner \phi \urcorner\) is true for every object \(d \in D\) when every occurance of \(x\) in \(\phi\) is 
replaced with a term denoting \(d\)}
\]</span></p><p><span class="mathjax">\[
\ulcorner \exists x \phi \urcorner \: \textrm{is true iff the formula \(\ulcorner \phi \urcorner\) is true for at least one object \(d \in D\) when every occurance of \(x\) in \(\phi\) is replaced with a term denoting \(d\)}
\]</span></p><p>Again, the differences between this definition and the definition for propositional logic have to do with the predicate clause, the equality clause, and the quantifier clauses. The 
predicate clause explains that a predicate is true of its terms iff the n-tuple of objects denoted by those terms are in the relation which <span class="mathjax">\(I\)</span> assigns to the predicate. The idea that 
a sentence <span class="mathjax">\(\ulcorner t_1 = t_2 \urcorner\)</span> is true just in case the terms denote the same object is sometimes called extensionality. In modal and intensional logics, the way in which 
an object is designated can matter greatly to the question of equality, and so the clause for <span class="mathjax">\(\ulcorner t_1 = t_2 \urcorner\)</span> might not hold in those logics. Here, however, we only 
care about extensional equality. The quantifiers clauses formalize the intuitive idea that a universally quantified sentence is only true if it's true of every object in the domain, and 
an existenetially quantified sentence is similarly only true if its true of at least one object in the domain.</p><p>It's important to understand that asking whether or not a formula with unbound variables is true makes no sense. It depends on what the variable stands for, and without any sort of 
quantifying, there isn't a coherent way to figure that out. This is why we only consider sentences and not open formulae in the truth conditions. </p><p>In general, there are at least three common ways of dealing with the problem of open formulae and they all involve binding or replacing the unbound variables. The first way is to just 
agree that we will only ever try to interpret a closed formula. The second way is to treat every occurance of an unbound variable as implicitly being bound by one of 
the quantifiers (usually <span class="mathjax">\(\forall\)</span>). The third way is to include another parameter in our evaluation process which is usually referred to as an &quot;assignment function&quot; which 
takes a variable and assigns it a constant name referring to some object in the domain. The effect of the second and third options is that before we evaluate the formula, we rewrite 
it as a closed formula by either binding all of the unbound variables with a universal quantifier or reassigning all of the free variables according to the assignment function.</p><p>Option three is very common, but it's extra work. Option two is fine, but it can be somewhat unintuitive if you don't see a bias towards universal quantification. Option 
one is what this implementation chooses, and it does so by making unbound variables unrepresentable. A variable can only appear in the scope of a quantifier, because the 
quantifiers are written using Haskell's own variables. Terms in the implementation are always constants, so there cannot be a syntactically correct string containing an 
unbound variable. At some point during the evaluation process, the formula needs to become closed. All three ways outlined above are perfectly acceptable, but leveraging 
Haskell's own variables allows for removing a lot of the headache of managing scope.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:QuantificationalTerm">QuantificationalTerm</a> = <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:QuantificationalFormula">QuantificationalFormula</a><ul class="subs"><li>= <a href="#v:Predicate">Predicate</a> <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a> [<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a>]</li><li>| <a href="#v:Equality">Equality</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a></li><li>| <a href="#v:Negation">Negation</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a></li><li>| <a href="#v:Conjunction">Conjunction</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a></li><li>| <a href="#v:Disjunction">Disjunction</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a></li><li>| <a href="#v:Implication">Implication</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a></li><li>| <a href="#v:Universal">Universal</a> (<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a>)</li><li>| <a href="#v:Existential">Existential</a> (<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a>)</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Domain">Domain</a> = <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/containers-0.6.5.1/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:createDomain">createDomain</a> :: [<a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a>] -&gt; <a href="Semantics-Logic-Quantificational.html#t:Domain" title="Semantics.Logic.Quantificational">Domain</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:RelationalTuples">RelationalTuples</a> = <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/containers-0.6.5.1/Data-Set.html#t:Set" title="Data.Set">Set</a> [<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a>]</li><li class="src short"><a href="#v:createRelationalTuple">createRelationalTuple</a> :: [[<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a>]] -&gt; <a href="Semantics-Logic-Quantificational.html#t:RelationalTuples" title="Semantics.Logic.Quantificational">RelationalTuples</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Relations">Relations</a> = <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/containers-0.6.5.1/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a> <a href="Semantics-Logic-Quantificational.html#t:RelationalTuples" title="Semantics.Logic.Quantificational">RelationalTuples</a></li><li class="src short"><a href="#v:createRelations">createRelations</a> :: [(<a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a>, <a href="Semantics-Logic-Quantificational.html#t:RelationalTuples" title="Semantics.Logic.Quantificational">RelationalTuples</a>)] -&gt; <a href="Semantics-Logic-Quantificational.html#t:Relations" title="Semantics.Logic.Quantificational">Relations</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Interpretation">Interpretation</a> = (<a href="Semantics-Logic-Quantificational.html#t:Domain" title="Semantics.Logic.Quantificational">Domain</a>, <a href="Semantics-Logic-Quantificational.html#t:Relations" title="Semantics.Logic.Quantificational">Relations</a>)</li><li class="src short"><a href="#v:createInterpretation">createInterpretation</a> :: <a href="Semantics-Logic-Quantificational.html#t:Domain" title="Semantics.Logic.Quantificational">Domain</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:Relations" title="Semantics.Logic.Quantificational">Relations</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:Interpretation" title="Semantics.Logic.Quantificational">Interpretation</a></li><li class="src short"><a href="#v:evaluateIn">evaluateIn</a> :: <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:Interpretation" title="Semantics.Logic.Quantificational">Interpretation</a> -&gt; <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Syntax</h1></a><a href="#g:2" id="g:2"><h2>Abstract Syntax</h2></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:QuantificationalTerm" class="def">QuantificationalTerm</a> = <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a> <a href="#t:QuantificationalTerm" class="selflink">#</a></p><div class="doc"><p>A quantificational term is the name of a constant.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:QuantificationalFormula" class="def">QuantificationalFormula</a> <a href="#t:QuantificationalFormula" class="selflink">#</a></p><div class="doc"><p>A quantificational formula is a well formed abstract syntax tree encoding its logical form.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Predicate" class="def">Predicate</a> <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a> [<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a>]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Equality" class="def">Equality</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Negation" class="def">Negation</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Conjunction" class="def">Conjunction</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Disjunction" class="def">Disjunction</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Implication" class="def">Implication</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a> <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Universal" class="def">Universal</a> (<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Existential" class="def">Existential</a> (<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><a href="#g:3" id="g:3"><h1>Semantics </h1></a><a href="#g:4" id="g:4"><h2>Model Structure</h2></a><a href="#g:5" id="g:5"><h3>Domain</h3></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Domain" class="def">Domain</a> = <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/containers-0.6.5.1/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a> <a href="#t:Domain" class="selflink">#</a></p><div class="doc"><p>A domain is a set of entities.</p></div></div><div class="top"><p class="src"><a id="v:createDomain" class="def">createDomain</a> :: [<a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a>] -&gt; <a href="Semantics-Logic-Quantificational.html#t:Domain" title="Semantics.Logic.Quantificational">Domain</a> <a href="#v:createDomain" class="selflink">#</a></p><div class="doc"><p>Create a domain.</p></div></div><a href="#g:6" id="g:6"><h3>Relations</h3></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:RelationalTuples" class="def">RelationalTuples</a> = <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/containers-0.6.5.1/Data-Set.html#t:Set" title="Data.Set">Set</a> [<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a>] <a href="#t:RelationalTuples" class="selflink">#</a></p><div class="doc"><p>A relational tuple is a set of lists of quantificational terms</p></div></div><div class="top"><p class="src"><a id="v:createRelationalTuple" class="def">createRelationalTuple</a> :: [[<a href="Semantics-Logic-Quantificational.html#t:QuantificationalTerm" title="Semantics.Logic.Quantificational">QuantificationalTerm</a>]] -&gt; <a href="Semantics-Logic-Quantificational.html#t:RelationalTuples" title="Semantics.Logic.Quantificational">RelationalTuples</a> <a href="#v:createRelationalTuple" class="selflink">#</a></p><div class="doc"><p>Create a RelationalTuple</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Relations" class="def">Relations</a> = <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/containers-0.6.5.1/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a> <a href="Semantics-Logic-Quantificational.html#t:RelationalTuples" title="Semantics.Logic.Quantificational">RelationalTuples</a> <a href="#t:Relations" class="selflink">#</a></p><div class="doc"><p>Relations are the collections of objects satisfying them.</p></div></div><div class="top"><p class="src"><a id="v:createRelations" class="def">createRelations</a> :: [(<a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-String.html#t:String" title="Data.String">String</a>, <a href="Semantics-Logic-Quantificational.html#t:RelationalTuples" title="Semantics.Logic.Quantificational">RelationalTuples</a>)] -&gt; <a href="Semantics-Logic-Quantificational.html#t:Relations" title="Semantics.Logic.Quantificational">Relations</a> <a href="#v:createRelations" class="selflink">#</a></p><div class="doc"><p>Create a collection of relations.</p></div></div><a href="#g:7" id="g:7"><h3>Interpretation</h3></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Interpretation" class="def">Interpretation</a> = (<a href="Semantics-Logic-Quantificational.html#t:Domain" title="Semantics.Logic.Quantificational">Domain</a>, <a href="Semantics-Logic-Quantificational.html#t:Relations" title="Semantics.Logic.Quantificational">Relations</a>) <a href="#t:Interpretation" class="selflink">#</a></p><div class="doc"><p>An interpretation is a domain and a collection of relations on it.</p></div></div><div class="top"><p class="src"><a id="v:createInterpretation" class="def">createInterpretation</a> :: <a href="Semantics-Logic-Quantificational.html#t:Domain" title="Semantics.Logic.Quantificational">Domain</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:Relations" title="Semantics.Logic.Quantificational">Relations</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:Interpretation" title="Semantics.Logic.Quantificational">Interpretation</a> <a href="#v:createInterpretation" class="selflink">#</a></p><div class="doc"><p>Create an interpretation.</p></div></div><a href="#g:8" id="g:8"><h2>Evaluation</h2></a><div class="top"><p class="src"><a id="v:evaluateIn" class="def">evaluateIn</a> :: <a href="Semantics-Logic-Quantificational.html#t:QuantificationalFormula" title="Semantics.Logic.Quantificational">QuantificationalFormula</a> -&gt; <a href="Semantics-Logic-Quantificational.html#t:Interpretation" title="Semantics.Logic.Quantificational">Interpretation</a> -&gt; <a href="file://C:\ghcup\ghc\8.10.7\lib/../doc/html/libraries/base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:evaluateIn" class="selflink">#</a></p><div class="doc"><p>Evaluate the truth of a closed formula in an interpretation.</p><p>Let i be an interpretation with domain Laura, BOB, and Cooper,
 and relations</p><pre>InTheBlackLodge = {Laura, BOB}
InGlastonburyGrove = {Cooper}
</pre><p>then </p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>evaluateIn (Universal $ \x -&gt; (Disjunction (Predicate &quot;InTheBlackLodge&quot; [x]) (Equality x &quot;Cooper&quot;))) i
</code></strong>True
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>